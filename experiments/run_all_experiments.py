##runs all experiments in a folder generated by experiment_set_up.py
##Uses allsat
import os
import subprocess
from glob import glob
import time


def run_command(command, input=""):
    """Runs a command with stdin input and returns stdout"""
    try:
        logs = subprocess.run(command, check=True, stdout=subprocess.PIPE, shell=True, text=True).stdout
    except subprocess.CalledProcessError as e:
        logs = e.stdout

    return logs

def start_instance(command, instance, outfile):
    print(f"Starting instance: {instance}")
    p = subprocess.Popen(command.split() + [instance], stdout=outfile, stderr=subprocess.STDOUT, universal_newlines=True)
    return p

def finished(path):
    ##Checks if the file path/sol.txt exists and contains the word "FINISHED"
    FINISH = "FINISHED"
    if os.path.exists(path + "sol.txt"):
        finished = False
        with open(path + "sol.txt", 'r') as f:
            if FINISH in f.read():
                finished = True
        return finished
    return False

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Runs all experiments in a folder generated by experiment_set_up.py')
    parser.add_argument('-d', '--dimensions', nargs=3, type=int,
                        help='Dimensions of faces of boxes, should be a list of 3 numbers', required=True)

    parser.add_argument('-c', '--cadical', type=str, help='path to allsat-cadical solver', required=True)
    parser.add_argument('--threads', type=int, help='Number of threads. Default = 1', default=1)
    parser.add_argument('-t','--time', type=int, help='Time limit per instance.', default=-1)

    args = parser.parse_args()
    solver_path = args.cadical
    threads = args.threads
    dims = args.dimensions
    time_lim = args.time
    mode = "w"

    edge_cnt = 4 * (dims[0] * dims[1] + dims[0] * dims[2] + dims[1] * dims[2])

    if time_lim > 0:
        solver_cmd = f"{solver_path} -q --allsat --probvars={edge_cnt} -t {time_lim}"
    else:
        solver_cmd = f"{solver_path} -q --allsat --probvars={edge_cnt}"

    faces = [str(x) for x in range(6)]
    instances = [path for path in glob("*/") if path[0] in faces and not finished(path)]
    prev_solved_instances = [path for path in glob("*/") if path[0] in faces and finished(path)]

    print(f"Total unsolved: {len(instances)} instances")
    print(f"Previously solved: {len(prev_solved_instances)} instances")
    print(f"Total: {len(instances) + len(prev_solved_instances)}")

    processes = {}

    for i in range(threads):
        cnf = instances[-1] + "encoding.cnf"
        sol = instances[-1] + "sol.txt"
        outfile = open(sol, mode)
        p = start_instance(solver_cmd, cnf, outfile)
        processes[instances[-1]] = [p, outfile, time.time()]
        del instances[-1]
        if len(instances) == 0:
            break
    solved = 0

    while len(processes) > 0:
        pid, status = os.wait()
        check = list(processes.items())
        for instance, data in check:
            if data[0].pid == pid:
                data[0]._handle_exitstatus(status)
                solved += 1
                print(f"Instance: {instance[:-1]} completed Total solved: {solved} Time taken: {time.time() - data[2]:.2f} seconds")
                ##Start new process here if possible
                # with open(instance + "/sol.txt", 'w') as f:
                #     f.write(p.stdout.read())
                data[0].kill()
                data[1].write("FINISHED\n")
                data[1].close()
                del processes[instance]
                if len(instances) > 0:
                    sol = instances[-1] + "sol.txt"
                    outfile = open(sol, mode)
                    p = start_instance(solver_cmd, instances[-1] + "encoding.cnf", outfile)
                    processes[instances[-1]] = [p, outfile, time.time()]
                    del instances[-1]

